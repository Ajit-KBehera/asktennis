const fs = require('fs');
const path = require('path');
const csv = require('csv-parser');
const database = require('./database/connection');

class CSVDataLoader {
  constructor() {
    this.dataDirectory = path.join(__dirname, '../data');
    this.completeDatasetPath = '/Users/ajitbehera/Tennis Data(Master)/databases/complete_tennis_data.csv';
    this.isLoading = false;
    this.lastLoadTime = null;
    this.loadStats = {
      matches: 0,
      players: 0,
      rankings: 0,
      errors: 0
    };
  }

  /**
   * Check if complete dataset exists
   */
  hasCSVData() {
    return fs.existsSync(this.completeDatasetPath);
  }

  /**
   * Get list of available CSV files
   */
  getAvailableFiles() {
    if (!this.hasCSVData()) {
      return [];
    }

    return ['complete_tennis_data.csv'];
  }

  /**
   * Load all CSV data into database
   */
  async loadAllData() {
    if (this.isLoading) {
      throw new Error('Data loading already in progress');
    }

    if (!this.hasCSVData()) {
      throw new Error('Complete tennis dataset not found at: ' + this.completeDatasetPath);
    }

    this.isLoading = true;
    this.loadStats = { matches: 0, players: 0, rankings: 0, errors: 0 };

    try {
      console.log('üîÑ Starting CSV data loading...');
      
      // Ensure database connection
      if (!database.pool) {
        await database.connect();
      }

      console.log('üìÅ Loading complete tennis dataset...');
      console.log(`üìä Dataset path: ${this.completeDatasetPath}`);

      // Load the complete dataset
      await this.loadCompleteDataset();

      this.lastLoadTime = new Date();
      console.log('‚úÖ CSV data loading completed successfully');
      console.log(`üìä Loaded: ${this.loadStats.matches} matches, ${this.loadStats.players} players, ${this.loadStats.rankings} rankings`);

      return {
        success: true,
        stats: this.loadStats,
        lastLoad: this.lastLoadTime
      };

    } catch (error) {
      console.error('‚ùå CSV data loading failed:', error.message);
      throw error;
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * Load the complete tennis dataset
   */
  async loadCompleteDataset() {
    console.log('üéæ Loading complete tennis dataset...');
    console.log(`üìä File size: ${this.getFileSize()} MB`);

    return new Promise((resolve, reject) => {
      const results = [];
      let processedCount = 0;
      const batchSize = 1000; // Process in batches of 1000 records
      
      const client = database.pool.connect();

      client.then(async (dbClient) => {
        try {
          await dbClient.query('BEGIN');

          fs.createReadStream(this.completeDatasetPath)
            .pipe(csv())
            .on('data', (data) => {
              results.push(data);
              
              // Process in batches to avoid memory issues
              if (results.length >= batchSize) {
                this.processBatch(dbClient, results.splice(0, batchSize));
                processedCount += batchSize;
                console.log(`üìä Processed ${processedCount} records...`);
              }
            })
            .on('end', async () => {
              try {
                // Process remaining records
                if (results.length > 0) {
                  await this.processBatch(dbClient, results);
                  processedCount += results.length;
                }

                await dbClient.query('COMMIT');
                console.log(`‚úÖ Complete dataset processed successfully (${processedCount} total records)`);
                resolve();
              } catch (error) {
                await dbClient.query('ROLLBACK');
                console.error(`‚ùå Error processing complete dataset:`, error.message);
                this.loadStats.errors++;
                reject(error);
              } finally {
                dbClient.release();
              }
            })
            .on('error', (error) => {
              console.error(`‚ùå Error reading complete dataset:`, error.message);
              this.loadStats.errors++;
              reject(error);
            });
        } catch (error) {
          console.error(`‚ùå Database error for complete dataset:`, error.message);
          this.loadStats.errors++;
          reject(error);
        }
      }).catch(reject);
    });
  }

  /**
   * Process a batch of records
   */
  async processBatch(client, batch) {
    for (const record of batch) {
      try {
        // Determine record type and process accordingly
        if (this.isMatchRecord(record)) {
          await this.processMatchRecord(client, record);
        } else if (this.isPlayerRecord(record)) {
          await this.processPlayerRecord(client, record);
        } else if (this.isRankingRecord(record)) {
          await this.processRankingRecord(client, record);
        }
      } catch (error) {
        console.error('Error processing record:', error.message);
        this.loadStats.errors++;
      }
    }
  }

  /**
   * Check if record is a match record
   */
  isMatchRecord(record) {
    const keys = Object.keys(record);
    return keys.some(key => 
      key.toLowerCase().includes('winner') || 
      key.toLowerCase().includes('loser') ||
      key.toLowerCase().includes('tournament') ||
      key.toLowerCase().includes('match')
    );
  }

  /**
   * Check if record is a player record
   */
  isPlayerRecord(record) {
    const keys = Object.keys(record);
    return keys.some(key => 
      key.toLowerCase().includes('player') ||
      key.toLowerCase().includes('name') ||
      key.toLowerCase().includes('country')
    ) && !this.isMatchRecord(record);
  }

  /**
   * Check if record is a ranking record
   */
  isRankingRecord(record) {
    const keys = Object.keys(record);
    return keys.some(key => 
      key.toLowerCase().includes('ranking') ||
      key.toLowerCase().includes('rank') ||
      key.toLowerCase().includes('points')
    );
  }

  /**
   * Process a single match record
   */
  async processMatchRecord(client, record) {
    try {
      await client.query(`
        INSERT INTO tennis_matches_simple (
          tourney_name, surface, year, winner, loser, set1, set2, set3, 
          round, minutes, winner_rank, loser_rank, tourney_level, draw_size
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        `, [
          record.tourney_name || record.tournament || record.tourney || 'Unknown',
          record.surface || 'Unknown',
          parseInt(record.year) || new Date().getFullYear(),
          record.winner || record.winner_name || 'Unknown',
          record.loser || record.loser_name || 'Unknown',
          record.set1 || record.score1 || '0-0',
          record.set2 || record.score2 || '0-0',
          record.set3 || record.score3 || '0-0',
          record.round || record.stage || 'Unknown',
          parseInt(record.minutes) || 0,
          parseInt(record.winner_rank) || 0,
          parseInt(record.loser_rank) || 0,
          record.tourney_level || record.level || 'Unknown',
          parseInt(record.draw_size) || 32
        ]);
        this.loadStats.matches++;
      } catch (error) {
        console.error('Error inserting match:', error.message);
        this.loadStats.errors++;
      }
    } catch (error) {
      console.error('Error processing match record:', error.message);
      this.loadStats.errors++;
    }
  }

  /**
   * Process a single player record
   */
  async processPlayerRecord(client, record) {
    try {
      await client.query(`
        INSERT INTO players (
          name, country, country_code, current_ranking, career_prize_money, 
          tour, gender, height, weight, birth_date
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        `, [
          record.name || record.player_name || 'Unknown Player',
          record.country || record.nationality || 'Unknown',
          record.country_code || record.country || 'UNK',
          parseInt(record.current_ranking) || parseInt(record.ranking) || null,
          parseInt(record.career_prize_money) || parseInt(record.prize_money) || 0,
          record.tour || 'ATP',
          record.gender || 'M',
          parseInt(record.height) || null,
          parseInt(record.weight) || null,
          record.birth_date || record.birthday || null
        ]);
        this.loadStats.players++;
      } catch (error) {
        console.error('Error inserting player:', error.message);
        this.loadStats.errors++;
      }
    } catch (error) {
      console.error('Error processing player record:', error.message);
      this.loadStats.errors++;
    }
  }

  /**
   * Process a single ranking record
   */
  async processRankingRecord(client, record) {
    try {
      // First, get or create player
      const playerResult = await client.query(
        'SELECT id FROM players WHERE name = $1',
        [record.player_name || record.name || 'Unknown']
      );

      let playerId;
      if (playerResult.rows.length === 0) {
        // Create player if not exists
        const insertResult = await client.query(`
          INSERT INTO players (name, country, country_code, tour, gender)
          VALUES ($1, $2, $3, $4, $5)
          RETURNING id
        `, [
          record.player_name || record.name || 'Unknown',
          record.country || 'Unknown',
          record.country_code || 'UNK',
          record.tour || 'ATP',
          record.gender || 'M'
        ]);
        playerId = insertResult.rows[0].id;
      } else {
        playerId = playerResult.rows[0].id;
      }

      // Insert ranking
      await client.query(`
        INSERT INTO rankings (player_id, ranking, points, tour, ranking_date)
        VALUES ($1, $2, $3, $4, $5)
      `, [
        playerId,
        parseInt(record.ranking) || parseInt(record.rank) || 0,
        parseInt(record.points) || 0,
        record.tour || 'ATP',
        record.ranking_date || record.date || new Date().toISOString().split('T')[0]
      ]);
      this.loadStats.rankings++;
    } catch (error) {
      console.error('Error processing ranking record:', error.message);
      this.loadStats.errors++;
    }
  }

  /**
   * Get file size in MB
   */
  getFileSize() {
    try {
      const stats = fs.statSync(this.completeDatasetPath);
      return (stats.size / (1024 * 1024)).toFixed(2);
    } catch (error) {
      return 'Unknown';
    }
  }

  /**
   * Load a specific CSV file
   */
  async loadCSVFile(filename) {
    const filePath = path.join(this.dataDirectory, filename);
    console.log(`üìÑ Processing ${filename}...`);

    return new Promise((resolve, reject) => {
      const results = [];
      const client = database.pool.connect();

      client.then(async (dbClient) => {
        try {
          await dbClient.query('BEGIN');

          fs.createReadStream(filePath)
            .pipe(csv())
            .on('data', (data) => {
              results.push(data);
            })
            .on('end', async () => {
              try {
                // Process data based on filename
                if (filename.includes('matches') || filename.includes('tennis')) {
                  await this.processMatchesData(dbClient, results);
                } else if (filename.includes('players')) {
                  await this.processPlayersData(dbClient, results);
                } else if (filename.includes('rankings')) {
                  await this.processRankingsData(dbClient, results);
                } else {
                  // Generic processing
                  await this.processGenericData(dbClient, results, filename);
                }

                await dbClient.query('COMMIT');
                console.log(`‚úÖ ${filename} processed successfully (${results.length} records)`);
                resolve();
              } catch (error) {
                await dbClient.query('ROLLBACK');
                console.error(`‚ùå Error processing ${filename}:`, error.message);
                this.loadStats.errors++;
                reject(error);
              } finally {
                dbClient.release();
              }
            })
            .on('error', (error) => {
              console.error(`‚ùå Error reading ${filename}:`, error.message);
              this.loadStats.errors++;
              reject(error);
            });
        } catch (error) {
          console.error(`‚ùå Database error for ${filename}:`, error.message);
          this.loadStats.errors++;
          reject(error);
        }
      }).catch(reject);
    });
  }

  /**
   * Process tennis matches data
   */
  async processMatchesData(client, data) {
    console.log(`üéæ Processing ${data.length} tennis matches...`);

    for (const match of data) {
      try {
        await client.query(`
          INSERT INTO tennis_matches_simple (
            tourney_name, surface, year, winner, loser, set1, set2, set3, 
            round, minutes, winner_rank, loser_rank, tourney_level, draw_size
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
          ON CONFLICT DO NOTHING
        `, [
          match.tourney_name || match.tournament || 'Unknown',
          match.surface || 'Unknown',
          parseInt(match.year) || new Date().getFullYear(),
          match.winner || match.winner_name || 'Unknown',
          match.loser || match.loser_name || 'Unknown',
          match.set1 || match.score1 || '0-0',
          match.set2 || match.score2 || '0-0',
          match.set3 || match.score3 || '0-0',
          match.round || match.stage || 'Unknown',
          parseInt(match.minutes) || 0,
          parseInt(match.winner_rank) || 0,
          parseInt(match.loser_rank) || 0,
          match.tourney_level || match.level || 'Unknown',
          parseInt(match.draw_size) || 32
        ]);
        this.loadStats.matches++;
      } catch (error) {
        console.error('Error inserting match:', error.message);
        this.loadStats.errors++;
      }
    }
  }

  /**
   * Process players data
   */
  async processPlayersData(client, data) {
    console.log(`üë• Processing ${data.length} players...`);

    for (const player of data) {
      try {
        await client.query(`
          INSERT INTO players (
            name, country, country_code, current_ranking, career_prize_money, 
            tour, gender, height, weight, birth_date
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
          ON CONFLICT (name) DO UPDATE SET
            country = EXCLUDED.country,
            country_code = EXCLUDED.country_code,
            current_ranking = EXCLUDED.current_ranking,
            career_prize_money = EXCLUDED.career_prize_money,
            tour = EXCLUDED.tour,
            gender = EXCLUDED.gender,
            height = EXCLUDED.height,
            weight = EXCLUDED.weight,
            birth_date = EXCLUDED.birth_date,
            updated_at = CURRENT_TIMESTAMP
        `, [
          player.name || player.player_name || 'Unknown Player',
          player.country || player.nationality || 'Unknown',
          player.country_code || player.country || 'UNK',
          parseInt(player.current_ranking) || parseInt(player.ranking) || null,
          parseInt(player.career_prize_money) || parseInt(player.prize_money) || 0,
          player.tour || 'ATP',
          player.gender || 'M',
          parseInt(player.height) || null,
          parseInt(player.weight) || null,
          player.birth_date || player.birthday || null
        ]);
        this.loadStats.players++;
      } catch (error) {
        console.error('Error inserting player:', error.message);
        this.loadStats.errors++;
      }
    }
  }

  /**
   * Process rankings data
   */
  async processRankingsData(client, data) {
    console.log(`üèÜ Processing ${data.length} rankings...`);

    for (const ranking of data) {
      try {
        // First, get or create player
        const playerResult = await client.query(
          'SELECT id FROM players WHERE name = $1',
          [ranking.player_name || ranking.name || 'Unknown']
        );

        let playerId;
        if (playerResult.rows.length === 0) {
          // Create player if not exists
          const insertResult = await client.query(`
            INSERT INTO players (name, country, country_code, tour, gender)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id
          `, [
            ranking.player_name || ranking.name || 'Unknown',
            ranking.country || 'Unknown',
            ranking.country_code || 'UNK',
            ranking.tour || 'ATP',
            ranking.gender || 'M'
          ]);
          playerId = insertResult.rows[0].id;
        } else {
          playerId = playerResult.rows[0].id;
        }

        // Insert ranking
        await client.query(`
          INSERT INTO rankings (player_id, ranking, points, tour, ranking_date)
          VALUES ($1, $2, $3, $4, $5)
          ON CONFLICT (player_id, ranking_date) DO UPDATE SET
            ranking = EXCLUDED.ranking,
            points = EXCLUDED.points,
            tour = EXCLUDED.tour
        `, [
          playerId,
          parseInt(ranking.ranking) || parseInt(ranking.rank) || 0,
          parseInt(ranking.points) || 0,
          ranking.tour || 'ATP',
          ranking.ranking_date || ranking.date || new Date().toISOString().split('T')[0]
        ]);
        this.loadStats.rankings++;
      } catch (error) {
        console.error('Error inserting ranking:', error.message);
        this.loadStats.errors++;
      }
    }
  }

  /**
   * Process generic CSV data
   */
  async processGenericData(client, data, filename) {
    console.log(`üìÑ Processing ${data.length} records from ${filename}...`);
    
    // Try to determine the data type from column names
    const firstRow = data[0];
    if (!firstRow) return;

    const columns = Object.keys(firstRow);
    
    if (columns.some(col => col.includes('winner') || col.includes('loser'))) {
      await this.processMatchesData(client, data);
    } else if (columns.some(col => col.includes('player') || col.includes('name'))) {
      await this.processPlayersData(client, data);
    } else if (columns.some(col => col.includes('ranking') || col.includes('rank'))) {
      await this.processRankingsData(client, data);
    } else {
      console.log(`‚ö†Ô∏è  Unknown data format in ${filename}, skipping...`);
    }
  }

  /**
   * Get loading status
   */
  getStatus() {
    return {
      isLoading: this.isLoading,
      lastLoad: this.lastLoadTime,
      hasData: this.hasCSVData(),
      availableFiles: this.getAvailableFiles(),
      stats: this.loadStats
    };
  }

  /**
   * Create sample CSV data if none exists
   */
  async createSampleData() {
    if (this.hasCSVData()) {
      console.log('üìÅ Complete tennis dataset already available');
      return;
    }

    console.log('üìù Creating sample CSV data...');

    // Create data directory
    if (!fs.existsSync(this.dataDirectory)) {
      fs.mkdirSync(this.dataDirectory, { recursive: true });
    }

    // Create sample tennis matches CSV
    const matchesData = [
      'tourney_name,surface,year,winner,loser,set1,set2,set3,round,minutes,winner_rank,loser_rank',
      'Wimbledon,Grass,2023,Carlos Alcaraz,Novak Djokovic,1-6,7-6(6),6-1,3-6,6-4,F,288,1,2',
      'US Open,Hard,2023,Novak Djokovic,Daniil Medvedev,6-3,7-6(5),6-3,,,F,195,2,3',
      'French Open,Clay,2023,Novak Djokovic,Casper Ruud,7-6(1),6-3,7-5,,,F,178,1,4',
      'Australian Open,Hard,2023,Novak Djokovic,Stefanos Tsitsipas,6-3,7-6(4),7-6(5),,,F,165,1,3'
    ];

    fs.writeFileSync(
      path.join(this.dataDirectory, 'tennis_matches_sample.csv'),
      matchesData.join('\n')
    );

    // Create sample players CSV
    const playersData = [
      'name,country,country_code,current_ranking,career_prize_money,tour,gender,height,weight',
      'Carlos Alcaraz,ESP,ESP,1,15000000,ATP,M,185,72',
      'Novak Djokovic,SRB,SRB,2,180000000,ATP,M,188,77',
      'Daniil Medvedev,RUS,RUS,3,25000000,ATP,M,198,83',
      'Rafael Nadal,ESP,ESP,4,140000000,ATP,M,185,85'
    ];

    fs.writeFileSync(
      path.join(this.dataDirectory, 'players_sample.csv'),
      playersData.join('\n')
    );

    console.log('‚úÖ Sample CSV data created');
  }

  /**
   * Clear all data from database
   */
  async clearAllData() {
    try {
      console.log('üóëÔ∏è  Clearing all data from database...');
      
      if (!database.pool) {
        await database.connect();
      }

      const client = await database.pool.connect();
      try {
        await client.query('BEGIN');
        
        await client.query('DELETE FROM rankings');
        await client.query('DELETE FROM tennis_matches_simple');
        await client.query('DELETE FROM players');
        
        await client.query('COMMIT');
        console.log('‚úÖ All data cleared from database');
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error('‚ùå Error clearing data:', error.message);
      throw error;
    }
  }
}

module.exports = new CSVDataLoader();
